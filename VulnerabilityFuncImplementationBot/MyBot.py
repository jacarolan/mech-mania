# keep these three import statements
import game_API
import fileinput
import json
import math

# your import statements here
import random

first_line = True # DO NOT REMOVE
average = 0

# global variables or other functions can go here
stances = ["Rock", "Paper", "Scissors"]

def get_winning_stance(stance):
    if stance == "Rock":
        return "Paper"
    elif stance == "Paper":
        return "Scissors"
    elif stance == "Scissors":
        return "Rock"

# main player script logic
# DO NOT CHANGE BELOW ----------------------------
for line in fileinput.input():
    if first_line:
        game = game_API.Game(json.loads(line))
        first_line = False
        continue
    game.update(json.loads(line))
# DO NOT CHANGE ABOVE ---------------------------

    # code in this block will be executed each turn of the game

    me = game.get_self()
    opponent = game.get_opponent()

    def canGetThere(start, end):

        if start == end:
            return (True, opponent.movement_counter - opponent.speed)

        shortestPath = game.shortest_paths(start, end)[0]
        opponent = game.get_opponent()  # made this cleaner

        myTime = 0

        for item in shortestPath:
            myTime += 7 - me.speed

        if game.has_monster(opponent.location):

            opponentMonsterHealth = game.get_monster(end).health
            opponentMonsterStance = game.get_monster(end).stance

            opponentStance = get_winning_stance(opponentMonsterStance)

            opponentStanceStats = 0

            if opponentStance == "Rock":
                opponentStanceStats = opponent.rock
            if opponentStance == "Paper":
                opponentStanceStats = opponent.paper
            if opponentStance == "Scissors":
                opponentStanceStats = opponent.scissors

            timeToKill = math.ceil(opponentMonsterHealth / opponentStanceStats)

            if timeToKill < myTime:
                return (False, 0)
            else:
                return (True, timeToKill)

        else:
            opponentTime = opponent.movement_counter - opponent.speed
            if opponentTime < myTime:
                return (False, 0)
            else:
                return (True, opponentTime)

    def valueOppLocation():
        if canGetThere(me.location, opponent.location)[0]:
            vulnerability = oppVulnerability()
            oppBenefit = oppBenefit()
            turns = canGetThere(me.location, opponent.location)[1]
            if me.movement_counter - me.speed < turns:
                turns = me.movement_counter - me.speed

        return turns*vulnerability


    def oppVulnerability():

        ourDamage = (float(me.rock)*float(me.scissors)*float(me.paper))**0.3333
        theirDamage = (float(opponent.rock)*float(opponent.scissors)*float(opponent.paper))**0.3333
        theirNewHealth = opponent.health - ourDamage
        ourNewHealth = opponent.health - theirDamage
        healthDamageRatio = float(me.health)/theirDamage - float(opponent.health)/ourDamage
        return healthDamageRatio

    #limited func only about what enemy gets from fighting a monster right now (if they are)
    def oppBenefit():
        if game.has_monster(opponent.location):
            monster = game.get_monster(opponent.location)
            return ({"Health": monster.death_effects.health,
                     "Rock": monster.death_effects.rock,
                     "Paper": monster.death_effects.paper,
                     "Scissors": monster.death_effects.scissors})
        else:
            return ("No monster")

    if me.location == me.destination: # check if we have moved this turn
        # get all living monsters closest to me
        monsters = game.nearest_monsters(me.location, 1)

        # choose a monster to move to at random
        monster_to_move_to = monsters[random.randint(0, len(monsters)-1)]

        # get the set of shortest paths to that monster
        paths = game.shortest_paths(me.location, monster_to_move_to.location)
        destination_node = paths[random.randint(0, len(paths)-1)][0]
    else:
        destination_node = me.destination

    if game.has_monster(me.location):
        # if there's a monster at my location, choose the stance that damages that monster
        chosen_stance = get_winning_stance(game.get_monster(me.location).stance)
    else:
        # otherwise, pick a random stance
        chosen_stance = stances[random.randint(0, 2)]

    # submit your decision for the turn (This function should be called exactly once per turn)
    game.log(str(oppVulnerability()))

    game.log(str(valueOppLocation()))
    average
    game.submit_decision(destination_node, chosen_stance)